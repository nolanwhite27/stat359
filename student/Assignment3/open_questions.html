<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>open_questions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="open_questions_files/libs/clipboard/clipboard.min.js"></script>
<script src="open_questions_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="open_questions_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="open_questions_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="open_questions_files/libs/quarto-html/popper.min.js"></script>
<script src="open_questions_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="open_questions_files/libs/quarto-html/anchor.min.js"></script>
<link href="open_questions_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="open_questions_files/libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="open_questions_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="open_questions_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="open_questions_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<ol type="1">
<li>Training Dynamics</li>
</ol>
<ol type="a">
<li>Did your models show signs of overfitting or underfitting? What architectural or training changes could address this?</li>
</ol>
<p>MLP Loss vs.&nbsp;Epochs <img src="loss_vs_epochs.png" class="img-fluid" alt="MLP Loss vs.&nbsp;Epochs"></p>
<p>MLP Accuracy vs.&nbsp;Epochs <img src="accuracy_vs_epochs.png" class="img-fluid" alt="MLP Accuracy vs.&nbsp;Epochs"></p>
<p>MLP Macro F1 vs.&nbsp;Epochs <img src="macro_f1_vs_epochs.png" class="img-fluid" alt="MLP Macro F1 vs.&nbsp;Epochs"></p>
<p>LSTM Loss vs.&nbsp;Epochs <img src="lstm_loss_vs_epochs.png" class="img-fluid" alt="LSTM Loss vs.&nbsp;Epochs"></p>
<p>LSTM Accuracy vs.&nbsp;Epochs <img src="lstm_accuracy_vs_epochs.png" class="img-fluid" alt="LSTM Accuracy vs.&nbsp;Epochs"></p>
<p>LSTM Macro F1 vs.&nbsp;Epochs <img src="lstm_macro_f1_vs_epochs.png" class="img-fluid" alt="LSTM Macro F1 vs.&nbsp;Epochs"></p>
<p>The MLP model shows more signs of mild overfitting than the LSTM model. In the loss curves, training loss continues decreasing steadily for MLP, while validation loss plateaus after approximately 10 epochs, with slight oscillation thereafter. For LSTM, although the validation loss also begins to stabilize around 10 epochs, it continues to trend downward more gradually over later epochs. Similarly, the macro-F1 curves show that the MLP’s validation performance plateaus earlier and exhibits a widening gap relative to training performance, whereas the LSTM maintains validation improvements further into training. This suggests that the LSTM’s additional capacity is being used to learn meaningful sequential structure rather than simply memorizing training data.</p>
<ol start="2" type="a">
<li>How did using class weights affect training stability and final performance?</li>
</ol>
<p>Adjusting for class imbalances increased sensitivity to minority classes and improved macro-f1 performance by penalizing misclassification of smaller weight classes more heavily. Although this introduced larger fluctuations in validation curves because of uneven gradient scaling, it led to more balanced classification behavior across the three sentiment categories. Overall accuracy was similar, but macro-f1 improved, evidencing better generalization across all classes instead of just the majority neutral class.</p>
<ol start="2" type="1">
<li>Model Performance and Error Analysis</li>
</ol>
<ol type="a">
<li>Which of your two models generalized better to the test set? Provide evidence from your metrics.</li>
</ol>
<p>My LSTM model generalized better to the test set. The test F1 score for my LSTM model was several points higher than my MLP model. 0.72 for LSTM vs.&nbsp;0.69 for MLP. This makes sense because LSTM processes text sequentially whereas MLP uses fixed input vectors. Word order matters in the LSTM model, but not for the MLP model. So overall performance on unseen data was better for LSTM than MLP.</p>
<p>Another way to look at generalization performance is to see how the train F1 scores compared to the test F1 scores for both models. For MLP, the test performance was 8 percentage points lower than its corresponding training performance. For LSTM, the difference was 10 points. So LSTM performance dropped more significantly on unseen data than did the MLP model, but only by a small amount. This might indicate more overfitting forL LSTM.</p>
<ol start="2" type="a">
<li>Which sentiment class was most frequently misclassified? Propose reasons for this pattern.</li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="mlp_confusion_matrix.png" class="img-fluid figure-img"></p>
<figcaption>MLP Confusion Matrix</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="lstm_confusion_matrix.png" class="img-fluid figure-img"></p>
<figcaption>LSTM Confusion Matrix</figcaption>
</figure>
</div>
<p>Based on the confusion matrices, the positive sentiment was most frequently misclassified by the LSTM model - around 33% of the time.</p>
<p>For MLP, this class was misclassified about 45% of the time. Most of the misclassifications mistook postive sentiment for neutral sentiment.</p>
<p>This could be because the positive sentiment content was relatively mild and was harder to differentiate from more neutral tones. Financial content tends to use more neutral phrasing, so positive sentiment is harder to capture. On the flip side, negative sentiment is likely easier to capture because this sort of criticism is often more direct.</p>
<ol start="3" type="1">
<li>Cross-Model Comparison</li>
</ol>
<p>Compare all six models: MLP, RNN, LSTM, GRU, BERT, GPT</p>
<ol type="a">
<li>How did mean-pooled FastText embeddings limit the MLP compared to sequence-based models?</li>
</ol>
<p>Mean-pooled fast text emebddings limited the MLP because averaging word vectors eliminates word order and compositional structure. The resulting representation prevents the model from capturing negation, modifier scope, and sequential dependencies. Sequence-based models process tokens in order and maintain contextual memory, allowing for interactions between words and allowing the model to capture more nuance.</p>
<ol start="2" type="a">
<li>What advantage did the LSTM’s sequential processing provide over the MLP?</li>
</ol>
<p>The LSTM’s sequential processing provided a structural advantage over the MLP by incorporating word order and contextual dependencies. As above, the LSTM processes tokens one at a time and maintains a memory state that captures interactions across word positions. Allows the model to capture negation, structure, and subtle effects that can make a big difference in sentiment.</p>
<ol start="3" type="a">
<li>Did fine-tuned LLMs (BERT/GPT) outperform classical baselines? Explain the performance gap in terms of pretraining and contextual representations.</li>
</ol>
<p>Yes, BERT and GPT clearly outperformed the classical baselines. The primary reason is large scale pretraiing, allowing transformers to learn complicated representations before the model is fine tuned. Unlike scratch trained models, BERT and GPT can encode grammer, syntax, and semantic relationships. Transformers generate contextual embeddings (word representations depend on the surrounding words), whereas classical baseline models rely on static embeddings and have to learn language structure from limited data. These differences explain the performance gap between fine-tuned models and the classical baselines.</p>
<ol start="4" type="a">
<li>Rank all six models by test performance. What architectural or representational factors explain the ranking?</li>
</ol>
<p>Based on the Macro F1 test performance, the following are the model rankings:</p>
<ol type="1">
<li>BERT 0.84 2. GPT 0.81 3. GRU 0.77 4. LSTM 0.70 5. MLP 0.69 6. RNN 0.66</li>
</ol>
<p>These may not reflect the expected results as the models I built might be out of place.</p>
<p>The results largely reflect differences in model architecture, capacity, and pretraining. Transformer based models outperformed more outdated baselines with pretraining and contextual embeddings capable of capturing bidirectionality. GRU surprisingly outperformed my LSTM model, perhaps due to its lower parameter count and optimization stability given the smaller dataset we were working with.</p>
<p>RNN performed the worse, which is consistent with its difficulty capturing long-range dependencies. The MLP model fell behidn sequence based models because it used mean-pooled embeddings, discarding word order and syntax structure.</p>
<p>In general, performance tended to increase with model complexity and representational capacity.</p>
<section id="ai-use-disclosure-required" class="level2">
<h2 class="anchored" data-anchor-id="ai-use-disclosure-required">AI Use Disclosure (Required)</h2>
<p>If you used any AI-enabled tools (e.g., ChatGPT, GitHub Copilot, Claude, or other LLM assistants) while working on this assignment, you must disclose that use here. The goal is transparency-not punishment.</p>
<p>In your disclosure, briefly include: - <strong>Tool(s) used:</strong> (name + version if known) - <strong>How you used them:</strong> (e.g., concept explanation, debugging, drafting code, rewriting text) - <strong>What you verified yourself:</strong> (e.g., reran the notebook, checked outputs/plots, checked shapes, read documentation) - <strong>What you did <em>not</em> use AI for (if applicable):</strong> (optional)</p>
<p>You are responsible for the correctness of your submission, even if AI suggested code or explanations.</p>
<section id="write-your-disclosure-here." class="level4">
<h4 class="anchored" data-anchor-id="write-your-disclosure-here."><font color="red">Write your disclosure here.</font></h4>
<p>I used ChatGPT 5.2 to help me debug and make code more concise. Especially with complex pytorch syntax and data loading problems. It also was helpful for formatting the required graphs and metrics. Also I used AI to help me understand the provided scripts more in depth.</p>
<p>I edited the code, analyzed outputs and charts, read documentation resources, and reformatted code myself. Did not use AI for the write up and open questions.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>